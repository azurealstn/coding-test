## p.159 선택정렬

- 선택정렬은 0부터 9까지의 숫자가 있을 때, 이 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고,
- 첫 번째 데이터는 정렬되었으니까 이제 두 번째부터 또 가장 작은 데이터를 선택해 2번째에 있는 데이터와 바꾼다
- 위 과정을 반복.
- 선택정렬은 (N - 1)번만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 한다. 그리고 매번 가장 작은 수를 찾기 위해 비교연산이 필요하다.
- 상수항은 무시되므로 선택정렬의 시간복잡도는 `O(N^2)`이다.

[Java코드](https://github.com/azurealstn/coding-test/blob/master/Sort/Selection.java)

## p.164 삽입정렬

- 데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입
- 1번째 원소는 정렬되어있다고 판단하고 그대로 두고, 2번째 원소부터 적절한 위치에 삽입
- 선택정렬보다 빠른게, 반복문으로 계속 비교하는 선택정렬과 다르게 이미 정렬되어있는 경우에는 무시하기 때문에 속도는 `삽입정렬 > 선택정렬` 이다.
- 삽입정렬의 최선의 경우에는 `O(N)`, 평균 속도는 `O(N^2)`

[Java코드](https://github.com/azurealstn/coding-test/blob/master/Sort/Insertion.java)

## p.168 퀵정렬

- 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸어 분할시킨다.
- 리스트에서 1번째 데이터를 피벗으로 정한다.
- 각 분할된 상태에서 다시 왼쪽과 오른쪽을 퀵정렬을 한다. (재귀적 함수)
- 시간복잡도는 `O(NlogN)`이다. 이는 데이터의 개수가 많으면 많을수록 압도적으로 빠른 속도를 자랑한다. 다만, 최악의 경우 `O(N^2)`이다.

[Java코드](https://github.com/azurealstn/coding-test/blob/master/Sort/Quick.java)

## p.171 계수 정렬

- 특정한 조건이 부합할 경우에만 사용가능하지만 그만큼 매우 빠른 정렬 알고리즘
- 데이터의 크기 범위가 제한되어 정수 형태로 표현할 경우에만 (반대로 무한한 범위를 가질 수 있는 실수형 데이터는 사용하기 어려움)

[Java코드](https://github.com/azurealstn/coding-test/tree/master/Sort/
